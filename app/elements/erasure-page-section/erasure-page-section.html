
<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="erasure-page-section">
  <template>
    <style>
      :host {
        display: block;
      }

    </style>

    <template>
      <div id="countDown">{{count}}</div>
    </template>

    <template is="dom-if" if="{{hasTitle(sectionContent.title)}}">
      <h2>{{sectionContent.title}}</h2>
    </template>

    <template is="dom-if" if="{{hasTitle(sectionContent.subtitle)}}">
      <h3>{{sectionContent.subtitle}}</h3>
    </template>

    <template is="dom-if" if="{{hasTitle(sectionContent.blockquote)}}">
      <blockquote>{{sectionContent.blockquote}}</blockquote>
    </template>

    <template is="dom-repeat" items="{{sectionContent.content}}">
      <p inner-h-t-m-l="{{item.paragraph}}"></p>
    </template>
  </template>
  <script>
    (function () {
      'use strict';

      Polymer({
        is: 'erasure-page-section',

        properties: {
          sectionContent: {
            type: Object,
            notify: true
          },
          count: {
            type: Number,
            value: 0,
            notify: true,
            observer: 'nextCount'
          }

        },

        hasTitle: function hasTitle(title) {
          return '' == !title;
        },

        _randomArrayMax: function randomArrayMax(numMax) {
          var randomArray = [];
          var maxRes = ((numMax * 10) / 100);
          for ( var i = 0; i < maxRes; i++ ) {
            randomArray[ i ] = Math.floor(Math.random() * numMax) + 1;
          }
          console.log('removing words at position ' + JSON.stringify(randomArray));
          return randomArray;
        },

        _curateParagraph: function curate(paragraph) {
          var wordParagraphList = paragraph.split(' ');
          //count the words and randomizes the injection of the tags
          this._randomArrayMax(wordParagraphList.length)
            .forEach(function (pos) {
              var word = '' + wordParagraphList[ pos ];
              console.log('about to check ' + word);
              wordParagraphList[ pos ] = word.replace(/./g, '_');
            });
          return wordParagraphList.join(' ');
        },

        _doIt: function () {
          console.log(':::called');
          var newContent = this.get('sectionContent.content');
          for ( var i = 0, l = newContent.length; i < l; i++ ) {
            if ( typeof (newContent[ i ].paragraph) === 'string' ) {
              var curatedPgph = this._curateParagraph(newContent[ i ].paragraph);
              //Forcing the deep array node to update
              this.set('sectionContent.content.' + i + '.paragraph', curatedPgph);
            } else {
              console.error('::: wrong content at the paragraph index ' + i)
            }
          }
        },

        nextCount: function () {
          // will not call `destroy` more than once per 3000ms, and data binding will update it
          this.debounce('destroy', function () {
            if ( this.count < 100 ) {
              var count = this.get('count');
              this.set('count', count + 1);
              console.log('here ' + count);
              this._doIt();
            }
          }, 3000);
        }

      });
    })();
  </script>
</dom-module>
